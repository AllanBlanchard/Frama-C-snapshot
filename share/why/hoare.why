(**************************************************************************)
(*                                                                        *)
(*  This file is part of Frama-C.                                         *)
(*                                                                        *)
(*  Copyright (C) 2007-2010                                               *)
(*    CEA   (Commissariat à l'énergie atomique et aux énergies            *)
(*           alternatives)                                                *)
(*    INRIA (Institut National de Recherche en Informatique et en         *)
(*           Automatique)                                                 *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version v2.1                *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(* shift_pointer (p, i) ==== p.[#(i)] *)
logic shift_pointer : pointer, int -> pointer

(* shift_field (ps, f) ==== ps.[+f] *)
logic shift_field : pointer, name -> pointer

(* shift_ufield (ps, f) ==== ps.[+f] *)
logic shift_ufield : pointer, name -> pointer

(* shift_index (pt, i) ==== pt.[+(i)] *)
logic shift_index : pointer, int -> pointer

axiom shift_zero : forall p:pointer. shift_pointer(p,0) = p

(* same than shift_neq + shift_zero
axiom shift_not_zero : forall p:pointer.  forall i:int. 
  i<>0 -> shift_pointer (p, i) <> p *)

axiom shift_neq : forall p:pointer.  forall i, j:int. 
  i<>j -> shift_pointer (p, i) <> shift_pointer (p, j)

axiom shift_shift_pointer : forall p:pointer .  forall i,j:int .
  shift_pointer(shift_pointer(p,i),j) = shift_pointer(p, add_int (i,j))

axiom shift_index_shift_pointer : forall pt:pointer. forall i,j:int.
  shift_pointer(shift_index(pt,i), j) = shift_index(pt, add_int (i,j))

axiom shift_field_other : forall p:pointer. forall f1, f2 : name.
  f1 <> f2 -> shift_field (p, f1) <> shift_field (p, f2)

logic m0_base : pointer -> pointer
logic m0_addr : name -> pointer

axiom base_addr : forall x: name.  m0_base(m0_addr (x)) = m0_addr (x)

axiom base_neq : forall p1, p2 : pointer.
  m0_base (p1) <> m0_base (p2) -> p1 <> p2

axiom base_shift_pointer : forall p:pointer. forall i:int.
  m0_base (shift_pointer (p, i)) = m0_base (p)

axiom base_shift_index : forall p:pointer. forall i:int.
  m0_base (shift_index (p, i)) = m0_base (p)

axiom base_shift_field : forall p:pointer. forall f : name.
  m0_base (shift_field (p, f)) = m0_base (p)

axiom base_shift_ufield : forall p:pointer. forall f : name.
  m0_base (shift_ufield (p, f)) = m0_base (p)

logic m0_equal_pointer : pointer,pointer -> bool

logic m0_minus_pointer : pointer,pointer -> int
logic m0_lt_pointer : pointer,pointer -> bool
logic m0_le_pointer : pointer,pointer -> bool

axiom equal_pointer_refl : forall p, q:pointer. 
  p = q -> m0_equal_pointer (p, q) = true

logic m0_null : pointer
logic m0_is_null : pointer -> bool

axiom is_null_def: m0_is_null(m0_null)=true 

logic m0_valid_pointer : pointer -> prop
logic m0_valid_set : pointer set -> prop
logic m0_valid_range : pointer, int set -> prop

(* dummy type : *)
type unknown_type

(* separated : named [disjoint] here because separated is already used by Store.
Maybe we can share the definition in data_lib ?
(even if the axioms are not shared between the models) *)
logic disjoint : pointer, pointer -> prop

axiom disj_sym : forall p1, p2 : pointer.
  disjoint (p1, p2) -> disjoint (p2, p1)

axiom disj_field : forall ps: (* struct *) pointer.  forall f1, f2 : name.  
  f1 <> f2 -> disjoint (shift_field (ps, f1), (shift_field (ps, f2)))

axiom disj_index : forall p: (*array*) pointer. forall i1, i2 : int.
  i1 <> i2 ->  disjoint (shift_index (p, i1), (shift_index (p, i2)))

axiom disj_shift : forall p: pointer. forall i1, i2 : int.
  i1 <> i2 ->  disjoint (shift_pointer (p, i1), (shift_pointer (p, i2)))

axiom disj_prop_field : forall p1, p2 : pointer.  forall f : name.
  disjoint (p1, p2) -> disjoint (p1, shift_field (p2, f))

axiom disj_prop_index : forall i : int. 
  forall p1 : pointer. forall p2 : (* array *) pointer.
  disjoint (p1, p2) -> disjoint (p1, shift_index (p2, i))

axiom disj_base : forall x, y :name. 
  x <> y -> disjoint (m0_addr (x), m0_addr (y))

axiom disj_neq : forall p1, p2 : pointer.  disjoint (p1, p2) -> p1 <> p2


