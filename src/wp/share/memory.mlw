(**************************************************************************)
(*                                                                        *)
(*  This file is part of WP plug-in of Frama-C.                           *)
(*                                                                        *)
(*  Copyright (C) 2007-2012                                               *)
(*    CEA (Commissariat a l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(* -------------------------------------------------------------------------- *)
(* --- Addresses and Memories for Alt-Ergo                                --- *)
(* -------------------------------------------------------------------------- *)

(* Addresses *)

type addr = { base : int ; offset : int }

predicate addr_le (p:addr,q:addr) = p.base = q.base and p.offset <= q.offset
predicate addr_lt (p:addr,q:addr) = p.base = q.base and p.offset <  q.offset
function addr_le_bool (p:addr,q:addr) : bool = andb(eqb(p.base,q.base),zleq(p.offset,q.offset))
function addr_lt_bool (p:addr,q:addr) : bool = andb(eqb(p.base,q.base),zlt(p.offset,q.offset))

(* Pointer Arithmetic *)

function shift( p:addr , k:int ) : addr = { p with offset = p.offset + k }

predicate included (p:addr,a:int,q:addr,b:int) =
  a > 0 -> ( b >= 0 and p.base = q.base 
                   and (q.offset <= p.offset)
                   and (p.offset + a <= q.offset + b) )

predicate separated (p:addr,a:int,q:addr,b:int) =
     a <= 0 or b <= 0 
  or p.base <> q.base 
  or q.offset + b <= p.offset
  or p.offset + a <= q.offset

predicate eqmem (m1:(addr,'a)farray, m2:(addr,'a)farray, p:addr, a:int) =
  forall q:addr [m1[q]|m2[q]]. included(q,1,p,a) -> m1[q] = m2[q]

predicate havoc (m1:(addr,'a)farray, m2:(addr,'a)farray, p:addr, a:int) =
  forall q:addr [m1[q]|m2[q]]. separated(q,1,p,a) -> m1[q] = m2[q]

predicate valid (m : int farray , p : addr , n : int) =
  (n > 0) -> ( 0 <= p.offset and p.offset + n <= m[p.base] )

(* Regions *)

logic region : int -> int
logic linked : int farray -> prop
predicate framed( m : (addr,addr) farray ) = 
  forall p:addr [m[p]]. region(m[p].base) = 0

(* Cast to Integer *)

logic cast : addr -> int 
axiom cast_injective :
  forall p,q : addr [cast(p),cast(q)]. cast(p) = cast(q) -> p = q

(* Physical Addresses *)

logic hardware : int -> int (* returns the offset in base NULL *)

(* To be discussed:
logic hardware_injective :
  forall p,q : int [hardware(p),hardware(q)]. hardware(p) = hardware(q) -> p = q
*)
